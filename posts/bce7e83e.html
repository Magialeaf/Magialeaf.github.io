<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Python高级 | Magialeaf的小窝</title><meta name="author" content="Maigaleaf"><meta name="copyright" content="Maigaleaf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Python高级内容概述">
<meta property="og:type" content="article">
<meta property="og:title" content="Python高级">
<meta property="og:url" content="http://magialeaf.github.io/posts/bce7e83e.html">
<meta property="og:site_name" content="Magialeaf的小窝">
<meta property="og:description" content="Python高级内容概述">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://magialeaf.github.io/img/default_cover_3.png">
<meta property="article:published_time" content="2024-03-23T04:00:00.000Z">
<meta property="article:modified_time" content="2024-05-07T11:11:38.747Z">
<meta property="article:author" content="Maigaleaf">
<meta property="article:tag" content="概述">
<meta property="article:tag" content="python">
<meta property="article:tag" content="程序语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://magialeaf.github.io/img/default_cover_3.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://magialeaf.github.io/posts/bce7e83e.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"距离上次更新已经过去","messageNext":"天了，文章内容可能已经过期！"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Maigaleaf","link":"链接: ","source":"来源: Magialeaf的小窝","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Python高级',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-07 19:11:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/readPercent.css"><link rel="stylesheet" href="/css/announcement.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa-solid fa-bookmark"></i><span> 作品</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/works/"><i class="fa-fw fa-sharp fa-solid fa-star"></i><span> 作品集</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa-solid fa-comment"></i><span> 社区</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_cover_3.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Magialeaf的小窝"><span class="site-name">Magialeaf的小窝</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><!-- span=' '+_p('search.title')--></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa-solid fa-bookmark"></i><span> 作品</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/works/"><i class="fa-fw fa-sharp fa-solid fa-star"></i><span> 作品集</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa-solid fa-comment"></i><span> 社区</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python高级</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-03-23T04:00:00.000Z" title="发表于 2024-03-23 12:00:00">2024-03-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-07T11:11:38.747Z" title="更新于 2024-05-07 19:11:38">2024-05-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Python高级"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Python高级"><a href="#Python高级" class="headerlink" title="Python高级"></a>Python高级</h1><hr>
<h2 id="一、内存管理"><a href="#一、内存管理" class="headerlink" title="一、内存管理"></a>一、内存管理</h2><h3 id="1-内部结构"><a href="#1-内部结构" class="headerlink" title="1 内部结构"></a>1 内部结构</h3><h4 id="1-1-环状双向链表"><a href="#1-1-环状双向链表" class="headerlink" title="1.1 环状双向链表"></a>1.1 环状双向链表</h4><blockquote>
<p>环状双向链表（<code>refchain</code>）。在python程序中创建的任何对象都会放在<code>refchain</code>链表中。</p>
<p><code>static PyObject refchain = &#123;&amp;refchain, &amp;refchain, ...&#125;</code></p>
<p>假设我<code>name = &quot;Bob&quot;</code>，内部的结构体会存上：上一对象、下一对象、类型、引用个数等内容。如果此时我再<code>new = name</code>，那么引用个数则会增加1个。</p>
<p>对于所有对象来说，内部结构体都会存上上一对象、下一对象、类型、引用个数，而不同的数据类型还会存储一切额外内容。比如创建<code>int</code>还会将<code>int</code>值存入结构体，创建<code>list</code>还会将列表，列表长度存入结构体。</p>
<p>综上：每个对象都有<code>PyObject</code>结构体，由多个元素组成的对象则是：<code>PyObject</code> + <code>ob_size</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C语言源码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pyobject_HEAD Pyobject ob_base;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pyobject_VAR_HEAD PyVarobject ob_base;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义，包含 上一个、下一个，用于构造双向链表（放到refchain链表中时要用到）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Pyobject_HEAD_EXTRA  \</span></span><br><span class="line"><span class="meta">    struct _object *_ob_next;  \</span></span><br><span class="line"><span class="meta">    struct _object *_ob_prev;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA  <span class="comment">// 用于构造双向链表</span></span><br><span class="line">    Py_ssize_t ob_refcnt;  <span class="comment">// 引用计数器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span>  <span class="comment">// 数据类型</span></span><br><span class="line">&#125; PyObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;  <span class="comment">// Pyobject对象</span></span><br><span class="line">    Py_ssize_t ob_size;  <span class="comment">// Number of items in variable part，即：元素个数</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-具体类型结构体"><a href="#1-2-具体类型结构体" class="headerlink" title="1.2 具体类型结构体"></a>1.2 具体类型结构体</h4><blockquote>
<p>假设设置了<code>data=3.14</code>，那么内部会创建：</p>
<ul>
<li><code>_ob_prev = refchain 中上一个对象</code></li>
<li><code>_ob_next = refchain 中下一个对象</code></li>
<li><code>ob_refcnt = 1</code></li>
<li><code>ob_type = float</code></li>
<li><code>ob_fval = 3.14</code></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// float</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="type">double</span> ob_fval; </span><br><span class="line">&#125; PyFloatObject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// int</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    digit ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Long (arbitrary precision) integer object inerface */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> <span class="title">PyLongObject</span>;</span> <span class="comment">/* Revealed in longintrepr.h */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// list</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// tuple</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject **ob_item[<span class="number">1</span>];</span><br><span class="line">&#125; PyTupleObject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dict</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD </span><br><span class="line">    Py_ssize_t ma_used;</span><br><span class="line">    PyDictKeysObject *ma_keys;</span><br><span class="line">    PyObject **ma_values;</span><br><span class="line">&#125; PyDictObject;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-引用计数器"><a href="#1-3-引用计数器" class="headerlink" title="1.3 引用计数器"></a>1.3 引用计数器</h4><blockquote>
<p>当python程序运行时，会根据数据类型的不同找到其对应的结构体，根据结构体中的字段来进行创建相关的数据。然后将对象添加到refchain双向链表中。</p>
<p>在C源码中有两个关键的结构体：<code>PyObject</code>、<code>PyVarObject</code></p>
<p>每个对象中的<code>ob_refcnt</code>就是引用计数器，值默认为1，当有其他变量引用对象时，引用计数器就会发生变化。</p>
<p>当一个对象的引用计数器为0时，意味着没有人再使用这个对象了，这个对象就是垃圾，此时进行垃圾回收。</p>
<p>垃圾回收简单理解步骤（实际不止，可以看后续）：</p>
<ol>
<li>对象从<code>refchain</code>链表移除。</li>
<li>将对象销毁，内存归还。</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 注意，下列a、b对应的对象实际上是同一个 &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># a变量赋值：a对应对象引用计数器 + 1</span></span><br><span class="line">a = <span class="number">99999</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># b = a：b对应对象引用计数器 + 1</span></span><br><span class="line">b = a</span><br><span class="line"></span><br><span class="line"><span class="comment"># b变量删除：b对应对象引用计数器 - 1</span></span><br><span class="line"><span class="keyword">del</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment"># a变量删除：a对应对象引用计数器 - 1</span></span><br><span class="line"><span class="keyword">del</span> a</span><br></pre></td></tr></table></figure>
<h4 id="1-4-循环引用问题"><a href="#1-4-循环引用问题" class="headerlink" title="1.4 循环引用问题"></a>1.4 循环引用问题</h4><blockquote>
<p>只使用引用计数器来管理内存看似完美，实际上会存在循环引用问题。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v1 = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]  <span class="comment"># 创建列表对象v1并赋值，对象引用计数器为1</span></span><br><span class="line">v2 = [<span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>]  <span class="comment"># 创建列表对象v2并赋值，对象引用计数器为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把v2追加到v1中，v2对应的[44, 55, 66]对象的引用计数器加1，变为2</span></span><br><span class="line">v1.append(v2)</span><br><span class="line"><span class="comment"># 把v1追加到v2中，v1对应的[11, 22, 33]对象的引用计数器加1，变为2</span></span><br><span class="line">v2.append(v1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除变量v1，v1对象引用计数器减1</span></span><br><span class="line"><span class="keyword">del</span> v1</span><br><span class="line"><span class="comment"># 删除变量v2，v2对象引用计数器减1</span></span><br><span class="line"><span class="keyword">del</span> v2</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 此时v1，v2对象引用计数器还有1，那么这两个列表此时就会常驻在内存中 &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-标记清除"><a href="#2-标记清除" class="headerlink" title="2 标记清除"></a>2 标记清除</h3><blockquote>
<p>目的：为解决引用计数器循环引用的不足。</p>
<p>实现：在python的底层再维护一个链表，链表中专门放那些可能存在循环引用的对象<code>（list / tuple / dict / set）</code>。</p>
<p>在Python内部某种情况下触发，回去扫描可能存在循环应用的链表中的每个元素，检查是否有循环引用，如果有则让双方的引用计数器 -1。如果是0则垃圾回收。</p>
</blockquote>
<h3 id="3-分代回收"><a href="#3-分代回收" class="headerlink" title="3 分代回收"></a>3 分代回收</h3><blockquote>
<p>标记清除问题:</p>
<ul>
<li>什么时候扫描?</li>
<li>可能存在循环引用的链表扫描代价大，每次扫描耗时久。</li>
</ul>
<p>于是<code>python</code>引入了分代回收机制，在<code>python</code>内存管理系统将内存分为不同的世代，新创建的对象首先放在第0代。经过多次垃圾回收周期，如果对象依然存活，则会被提升至老一代，以此类推。</p>
<p>标记清除维护的列表就是指的是分代回收的三个列表，它包含了可能存在循环引用的对象，通过定期扫描这个列表来处理可能的循环引用问题。</p>
<p>将可能存在循环应用的对象维护成3个链表：</p>
<ul>
<li>0代：0代中对象个数达到700个则扫描一次。</li>
<li>1代：0代扫描10次，则1代扫描一次。</li>
<li>2代：1代扫描10次，则2代扫描一次。</li>
</ul>
</blockquote>
<h3 id="4-缓存机制"><a href="#4-缓存机制" class="headerlink" title="4 缓存机制"></a>4 缓存机制</h3><h4 id="4-1-总结"><a href="#4-1-总结" class="headerlink" title="4.1 总结"></a>4.1 总结</h4><blockquote>
<p>在python中维护了一个<code>refchain</code>的双向环状链表，这个链表中存储程序创建的所有对象，每种类型的对象中都有一个<code>ob_refcnt</code>引用计数器的值，引用个数+1、-1，最后当引用计数器变为0时会进行垃圾回收（对象销毁、<code>refchain</code>中移除）。</p>
<p>但是，在python中对于那些可以有多个元素组成的对象可能会存在循环引用的问题，为了解决这个问题python又引入了标记清除和分代回收，在其内部为了4个链表。</p>
<p>在源码内部当达到各自的阈值时，就会触发扫描链表进行标记清除的动作（有循环则各自-1）。</p>
</blockquote>
<h4 id="4-2-池"><a href="#4-2-池" class="headerlink" title="4.2 池"></a>4.2 池</h4><blockquote>
<p>作用于<code>int / str</code>类型。</p>
<p>为了避免重复创建和销毁一些常见对象，于是会维护一个池。</p>
<p>在启动解释器时，对于<code>int</code>类型，python内部会帮我们创建：<code>[-5, 256]</code>。对于<code>str</code>类型，会维护一个<code>unicode_latin1[256]</code>的链表，内部存所有的<code>ascii</code>字符，之后使用就不会再重复创建。</p>
<p>字符串驻留机制：Python会对长度为0到20个字符的由英文字符，数字，下划线构成的字符串进行驻留，下次再创建时，不会新开辟内存，通过<code>id()</code>可以发现值相等。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v1 = <span class="number">7</span>  <span class="comment"># 内存不会开辟内存，直接从池中取的</span></span><br><span class="line">v2 = <span class="number">9</span>  <span class="comment"># 内存不会开辟内存，直接从池中取的</span></span><br><span class="line">v3 = <span class="number">9</span>  <span class="comment"># 内存不会开辟内存，直接从池中取的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 地址一样，都是池里面拿的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(v2), <span class="built_in">id</span>(v3))</span><br></pre></td></tr></table></figure>
<h4 id="4-3-free-list"><a href="#4-3-free-list" class="headerlink" title="4.3 free_list"></a>4.3 free_list</h4><blockquote>
<p>作用于：<code>float / list / tuple / dict</code></p>
<p>当一个对象的引用计数器为0时，按理说应该回收，但是内部实际上不会直接回收，而是将对象添加到<code>free_list</code>链表中当缓存。以后再去创建对象时，不会重新开辟内存，而是直接使用<code>free_list</code>。</p>
<p><code>free_list</code>是由上限的，当<code>free_list</code>没满时引用计数器为0的对象才会加到<code>free_list</code>中，满了的话则会直接销毁对象。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开辟内存，内部存储结构中初始化值后存在refchain中</span></span><br><span class="line">v1 = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从refchain中移除，将对象添加到free_list中</span></span><br><span class="line"><span class="keyword">del</span> v1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不会重新开辟内存，去free_list中获取对象，对象内部数据初始化后，再放到refchain中</span></span><br><span class="line">v9 = <span class="number">999.99</span></span><br></pre></td></tr></table></figure>
<h3 id="5-源码剖析"><a href="#5-源码剖析" class="headerlink" title="5 源码剖析"></a>5 源码剖析</h3><h4 id="5-1-float-类型"><a href="#5-1-float-类型" class="headerlink" title="5.1 float 类型"></a>5.1 float 类型</h4><p><strong>创建</strong></p>
<blockquote>
<p><code>val = 3.14</code></p>
<p><code>int</code>类型和<code>float</code>很相似，只是<code>int</code>类型还会先去小数据池里找，没有才会创建。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/floatobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于缓存f1oat对象的链表</span></span><br><span class="line"><span class="type">static</span> PyFloatObject *free_list = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> numfree = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">PyObject *<span class="title function_">PyFloat_FromDouble</span><span class="params">(<span class="type">double</span> fval)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果free_list中有可用对象，则从free_list链表拿出来一个；否则为对象重新分配内存。</span></span><br><span class="line">    PyFloatobject *op = free_list;</span><br><span class="line">    <span class="keyword">if</span> (op != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        free_list = (PyFloatobject *) Py_TYPE(op);</span><br><span class="line">        numfree--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 根据float类型的大小，为f1oat对象重新分配内存。</span></span><br><span class="line">        op = (PyFloatobject *) PyObject_MALLOC(<span class="keyword">sizeof</span>(PyFloatobject));</span><br><span class="line">        <span class="keyword">if</span> (!op)</span><br><span class="line">            <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对float对象进行初始化，例如：引用计数器初始化为1、添加到refchain链表等。</span></span><br><span class="line">    <span class="comment">/* Inline PyObject_New */</span></span><br><span class="line">    (<span class="type">void</span>)PyObject_INIT(op, &amp;PyFloat_Type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对float对象赋值。即：op-&gt;ob_fval = fval;</span></span><br><span class="line">    op-&gt;ob_fval = fval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (PyObject *)op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Include/objimpl.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(Py_TYPE(op) = (typeobj)): 设置op对象的类型为typeobj。</span></span><br><span class="line"><span class="comment">_Py_NewReference((PyObject *)(op)): 为op对象增加一个引用计数。</span></span><br><span class="line"><span class="comment">(op): 返回初始化后的PyObject对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_INIT(op, typeobj) (Py_TYPE(op) = (typeobj), _Py_NewReference((PyObject *)(op)), (op))</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Obejct/object.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护了所有对象的一个环状双向链表</span></span><br><span class="line"><span class="type">static</span> PyObejct refchain = &#123;&amp;refchain, &amp;refchain&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _Py_AddToAllObjects(PyObject *op, <span class="type">int</span> force)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(force || op-&gt;ob_prev == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        op-&gt;_ob_next = refchain._ob_next;</span><br><span class="line">        op-&gt;_ob_prev = &amp;refchain;</span><br><span class="line">        refchain._ob_next-&gt;_ob_prev = op;</span><br><span class="line">        refchain._ob_next = op;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _Py_NewReference(PyObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    _Py_INC_REFTOTAL;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 引用计数器初始化为1</span></span><br><span class="line">    op-&gt;ob_refcnt = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对象添加到双向链表refchain中</span></span><br><span class="line">    _Py_AddToAllObjects(op, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    _Py_INC_TPALLOCS(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>引用</strong></p>
<blockquote>
<p><code>val = 3.14</code></p>
<p><code>data = val</code></p>
<p>项目中这样的引用关系会使原对象的引用计数器+1。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inlcude/object.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> _Py_INCREF(PyObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    _Py_INC_REFTOTAL;</span><br><span class="line">    <span class="comment">// 对象的引用计数器 + 1</span></span><br><span class="line">    op-&gt;ob_refcnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_INCREF(op) _Py_INCREF(_PyObject_CAST(op))</span></span><br></pre></td></tr></table></figure>
<p><strong>销毁</strong></p>
<blockquote>
<p><code>val = 3.14</code></p>
<p><code>del 3.14</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Include/object.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> _Py_DECREF(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> lineno, PyObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)filename; <span class="comment">/* may be unused, shut up -Wunused-parameter */</span></span><br><span class="line">    (<span class="type">void</span>)lineno; <span class="comment">/* may be unused, shut up -Wunused-parameter */</span></span><br><span class="line">    _Py_DEC_REFTOTAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数器-1，如果引用计数器为0，则执行 _Py_Dealloc 去缓存或垃圾回收</span></span><br><span class="line">    <span class="keyword">if</span> (--op-&gt;ob_refcnt != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> Py_REF_DEBUG</span></span><br><span class="line">        <span class="keyword">if</span> (op-&gt;ob_refcnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            _Py_NegativeRefcount(filename, lineno, op);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _Py_Dealloc(op);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Py_DECREF(op) _Py_DECREF(__FILE__, __LINE__, _PyObject_CAST(op))</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Objects/object.c</span></span><br><span class="line"><span class="type">void</span> _Py_Dealloc(PyObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 找到float类型的 tp_dealloc 函数</span></span><br><span class="line">    destructor dealloc = Py_TYPE(op)-&gt;tp_dealloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 refchain 双向链表中摘除此对象</span></span><br><span class="line">    _Py_ForgetReference(op);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 float 类型的 tp_dealloc 函数，去进行缓存或垃圾回收</span></span><br><span class="line">    (*dealloc)(op);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _Py_ForgetReference(PyObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在 refchain 链表中移除此对象</span></span><br><span class="line">    op-&gt;_ob_next-&gt;_ob_prev = op-&gt;_ob_prev;</span><br><span class="line">    op-&gt;_ob_prev-&gt;_ob_next = op-&gt;_ob_next;</span><br><span class="line">    op-&gt;_ob_next = op-&gt;_ob_prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    _Py_INC_TPFREES(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objects/floatobject.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyFloat_MAXFREELIST 100</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> numfree = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> PyFloatObject *free_list = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// float 类型中函数的对应关系</span></span><br><span class="line">PyTypeObject PyFloat_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;float&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(PyFloatObject),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// tp_dealloc 表示执行 float_dealloc 方法（destructor: float_dealloc）</span></span><br><span class="line">    (destructor) float_dealloc,      <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                               <span class="comment">/* tp_print */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">float_dealloc</span><span class="params">(PyFloatObject *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检测是否是 float 类型</span></span><br><span class="line">    <span class="keyword">if</span> (PyFloat_CheckExact(op))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检测 free_list 中缓存的个数是否已满，如果已满，则直接将对象销毁</span></span><br><span class="line">        <span class="keyword">if</span> (numfree &gt;= PyFloat_MAXFREELIST)</span><br><span class="line">        &#123;</span><br><span class="line">            PyObject_FREE(op);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将对象加入到 free_list 链表中</span></span><br><span class="line">        numfree++;</span><br><span class="line">        Py_TYPE(op) = (<span class="keyword">struct</span> _typeobject *) free_list;</span><br><span class="line">        free_list = op;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果不是完全匹配，则通过 tp_free 销毁对象</span></span><br><span class="line">        Py_TYPE(op)-&gt;tp_free((PyObject *) op);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-list-类型"><a href="#5-2-list-类型" class="headerlink" title="5.2 list 类型"></a>5.2 list 类型</h4><p><strong>创建</strong></p>
<blockquote>
<p><code>v =[11, 22, 33]</code></p>
</blockquote>
<hr>
<h2 id="二、多线程"><a href="#二、多线程" class="headerlink" title="二、多线程"></a>二、多线程</h2><h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1 进程和线程"></a>1 进程和线程</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><blockquote>
<p>线程：是计算机中可以被cpu调度的最小单元（真正在工作）。</p>
<p>进程：是计算机资源分配的最小单元（进程为线程提供资源）。</p>
<p>一个进程中可以有多个线程，同一个进程中的线程可以共享此进程中的资源。</p>
<p>通过进程和线程都可以将串行的程序变成并发。</p>
<p>Python的多线程主要是在用户态中创建线程，在内核态中也会创建线程，并且多个用户线程可以映射到多个内核线程上，形成多对多的映射关系。</p>
</blockquote>
<h4 id="1-2-多线程"><a href="#1-2-多线程" class="headerlink" title="1.2 多线程"></a>1.2 多线程</h4><blockquote>
<p>在同一个进程中开启多个线程执行任务。</p>
<p>子线程开始后，主线程会一直向下走，不会停止。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">url_list = &#123;</span><br><span class="line">    (<span class="string">&quot;1.mp4&quot;</span>, <span class="string">&quot;https://www.xxx.com/?id=1&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;2.mp4&quot;</span>, <span class="string">&quot;https://www.xxx.com/?id=2&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;3.mp4&quot;</span>, <span class="string">&quot;https://www.xxx.com/?id=3&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">file_name, video_url</span>):</span><br><span class="line">    res = requests.get(video_url)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(res.content)</span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> name, url <span class="keyword">in</span> url_list:</span><br><span class="line">    <span class="comment"># 创建线程，target是函数，args是参数</span></span><br><span class="line">    t = threading.Thread(target=task, args=(name, url))</span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<h4 id="1-3-多进程"><a href="#1-3-多进程" class="headerlink" title="1.3 多进程"></a>1.3 多进程</h4><blockquote>
<p>开启不同的进程执行任务（不同的进程中会自动创建一个线程）。</p>
<p>注：Linux系统使用fork创建进程，Windows使用spawn，Mac支持fork和spawn。在python3.8版本后默认使用spawn创建线程，所以程序会要求创建线程代码必须在<code>if __name__ == &#39;__main__&#39;:</code>下，否则会异常。</p>
<p>mac中可以修改创建线程使用的方式来避免改变创建方式。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="comment"># mac可以修改创建方式来改变创建方式（写在程序开头位置）</span></span><br><span class="line"><span class="comment"># multiprocessing.set_start_method(&#x27;fork&#x27;)</span></span><br><span class="line"></span><br><span class="line">url_list = &#123;</span><br><span class="line">    (<span class="string">&quot;1.mp4&quot;</span>, <span class="string">&quot;https://www.xxx.com/?id=1&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;2.mp4&quot;</span>, <span class="string">&quot;https://www.xxx.com/?id=2&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;3.mp4&quot;</span>, <span class="string">&quot;https://www.xxx.com/?id=3&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">file_name, video_url</span>):</span><br><span class="line">    res = requests.get(video_url)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(res.content)</span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows下必须放在main中（也可以写成一个函数，只要是在__main__下启动即可）</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> name, url <span class="keyword">in</span> url_list:</span><br><span class="line">        t = multiprocessing.Process(target=task, args=(name, url))</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>
<h4 id="1-4-GIL锁"><a href="#1-4-GIL锁" class="headerlink" title="1.4 GIL锁"></a>1.4 GIL锁</h4><blockquote>
<p>GIL，全局解释器锁（Global Interpreter Lock），是CPython解释器特有的东西，让一个进程中同一时刻只有一个线程可以被CPU调度。</p>
<p>如果程序想利用计算机的多核优势，让CPU同时处理一些任务，适合用多进程开发（即使资源开销大）</p>
<p>如果程序不需要计算机的多核优势，适合用多线程开发，比如网络下载文件，多用网卡而非CPU。</p>
<p>常见的程序开发中，计算操作需要使用CPU多核优势，IO操作不需要利用CPU的多核优势：</p>
<ul>
<li>计算密集型，用多进程，例如∶大量的数据计算【累加计算示例】。</li>
<li>IO密集型，用多线程，例如：文件读写、网络数据传输【下载抖音视频示例】。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算密集型（计算0 - 100000000）</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">start, end, queue</span>):</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end):</span><br><span class="line">        res += <span class="number">1</span></span><br><span class="line">    queue.put(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue = multiprocessing.Queue()</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    </span><br><span class="line">    p1 = multiprocessing.Process(target = task, args=(<span class="number">0</span>, <span class="number">50000000</span>, queue))</span><br><span class="line">    p1.start()</span><br><span class="line">    </span><br><span class="line">    p2 = multiprocessing.Process(target = task, args=(<span class="number">50000000</span>, <span class="number">100000000</span>, queue))</span><br><span class="line">    p2.start()</span><br><span class="line">    </span><br><span class="line">    v1 = queue.get(block=<span class="literal">True</span>)</span><br><span class="line">    v2 = queue.get(block=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(v1 + v2)</span><br><span class="line">    </span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(end_time - start_time)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># IO密集型（下载文件资源）</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line">url_list = &#123;</span><br><span class="line">    (<span class="string">&quot;1.mp4&quot;</span>, <span class="string">&quot;https://www.xxx.com/?id=1&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;2.mp4&quot;</span>, <span class="string">&quot;https://www.xxx.com/?id=2&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;3.mp4&quot;</span>, <span class="string">&quot;https://www.xxx.com/?id=3&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">file_name, video_url</span>):</span><br><span class="line">    res = requests.get(video_url)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(res.content)</span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> name, url <span class="keyword">in</span> url_list:</span><br><span class="line">        t = multiprocessing.Process(target=task, args=(name, url))</span><br><span class="line">        t.start()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 也可以使用综合方式</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread_task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Thread task executed&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">start, end</span>):</span><br><span class="line">    t1 = threading.Thread(target=thread_task)</span><br><span class="line">    t1.start()</span><br><span class="line"></span><br><span class="line">    t2 = threading.Thread(target=thread_task)</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t3 = threading.Thread(target=thread_task)</span><br><span class="line">    t3.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    p1 = multiprocessing.Process(target=task, args=(<span class="number">0</span>, <span class="number">5000000</span>))</span><br><span class="line">    p1.start()</span><br><span class="line"></span><br><span class="line">    p2 = multiprocessing.Process(target=task, args=(<span class="number">5000000</span>, <span class="number">10000000</span>))</span><br><span class="line">    p2.start()</span><br></pre></td></tr></table></figure>
<h3 id="2-多线程开发"><a href="#2-多线程开发" class="headerlink" title="2 多线程开发"></a>2 多线程开发</h3><h4 id="2-1-常见API"><a href="#2-1-常见API" class="headerlink" title="2.1 常见API"></a>2.1 常见API</h4><blockquote>
<p>IO密集型，用多线程，例如：文件读写、网络数据传输【下载抖音视频示例】</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程，target是函数名，args是传递的函数参数</span></span><br><span class="line">t = threading.Thread(target=task, args=(<span class="string">&#x27;xxx&#x27;</span>, ))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程准备就绪（等待CPU调度，不一定立刻执行），代码向下继续</span></span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待当前线程的任务执行完毕后再向下继续执行。</span></span><br><span class="line">t.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 守护线程（必须放在t.start()前）</span></span><br><span class="line">t.daemon = <span class="literal">True</span>  <span class="comment"># 设置为守护线程，主线程执行完毕后，子线程也自动关闭。</span></span><br><span class="line">t.daemon = <span class="literal">False</span>  <span class="comment"># 设置为非守护线程，主线程等待子线程，子线程执行完毕后，主线程才关闭。（默认）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程名称设置（必须放在t.start()前）</span></span><br><span class="line">t.name = <span class="string">&quot;thread_one&quot;</span></span><br><span class="line"><span class="comment"># 线程名称获取</span></span><br><span class="line">name = threading.current_thread().name</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(threading.Thread):</span><br><span class="line">    <span class="comment"># 重写run，当线程被start时会执行此处的代码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># self._args是传递进来的参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;执行此线程&quot;</span>, self._args)</span><br><span class="line">        </span><br><span class="line">t = MyThread(args=(<span class="number">100</span>, ))</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>
<h4 id="2-2-API使用"><a href="#2-2-API使用" class="headerlink" title="2.2 API使用"></a>2.2 API使用</h4><blockquote>
<p>在<code>t.join()</code>案例中，最终<code>print</code>的结果是随机的，因为存在CPU调度算法，所以一个线程不一定会完全执行完毕，可能在执行过程中就切换了。所以在开启<code>t1</code>，<code>t2</code>线程后，有可能加了一部分数，<code>t1</code>就切换成了<code>t2</code>，于是<code>join</code>就过去了，<code>t2</code>同理，所以最后的<code>number</code>就不会是0。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 流程（t.start()）</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Thread对象（线程），并传递参数</span></span><br><span class="line">t.threading.Thread(target=task, args=(<span class="string">&#x27;xxx&#x27;</span>, ))</span><br><span class="line"><span class="comment"># 线程准备就绪（等待CPU调度），代码向下继续</span></span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主线程执行完所有代码后不会结束，会等待所有子线程执行完毕</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;继续执行...&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 等待线程（t.join()）</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">loop = <span class="number">1000000</span></span><br><span class="line">number = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_add</span>(<span class="params">count</span>):</span><br><span class="line">    <span class="keyword">global</span> number</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(loop):</span><br><span class="line">        number += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_sub</span>(<span class="params">count</span>):</span><br><span class="line">    <span class="keyword">global</span> number</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(loop):</span><br><span class="line">        number -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=_add, args=(loop, ))</span><br><span class="line">t2 = threading.Thread(target=_sub, args=(loop, ))</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">t1.join()  <span class="comment"># t1线程执行完毕,才继续往后走</span></span><br><span class="line">t2.join()  <span class="comment"># t2线程执行完毕,才继续往后走</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(number)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用线程类下载</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DownloadThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        file_name, video_url = self._args</span><br><span class="line">        res = requests.get(video_url)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(res.content)</span><br><span class="line"></span><br><span class="line">url_list = &#123;</span><br><span class="line">    (<span class="string">&quot;1.mp4&quot;</span>, <span class="string">&quot;https://www.xxx.com/?id=1&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;2.mp4&quot;</span>, <span class="string">&quot;https://www.xxx.com/?id=2&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;3.mp4&quot;</span>, <span class="string">&quot;https://www.xxx.com/?id=3&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> url_list:</span><br><span class="line">    t = DownloadThread(args=(item[<span class="number">0</span>], item[<span class="number">1</span>]))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<h4 id="2-3-线程安全"><a href="#2-3-线程安全" class="headerlink" title="2.3 线程安全"></a>2.3 线程安全</h4><blockquote>
<p>因为CPU在执行的过程中，可能会轮流地执行线程。</p>
<p>因此可以给线程加锁，这样就可以保证一个线程被执行完才会执行另一个线程。</p>
<p>不同线程使用的锁必须是同一把锁，不然就没有加锁的意义了。</p>
<p>在开发的过程中要注意有些操作默认都是线程安全的（内部集成了锁的机制），我们在使用的时无需再通过锁再处理，比如<code>L.append(x)</code>等。</p>
<p>官网：<a target="_blank" rel="noopener" href="https://www.python.org/search/?q=atomic&amp;submit=">official::Python.org</a>，搜：<code>atomic</code></p>
<p>根据官网，常见线程安全的操作：</p>
<ul>
<li><code>L.append(x)</code></li>
<li><code>L1.extend(L2)</code></li>
<li><code>x = L[i]</code></li>
<li><code>x = L.pop()</code></li>
<li><code>L1[i:j] = L2</code></li>
<li><code>L.sort()</code></li>
<li><code>x = y</code></li>
<li><code>x.field = y</code></li>
<li><code>D[x] = y</code></li>
<li><code>D1.update(D2)</code></li>
<li><code>D.keys()</code></li>
</ul>
<p>常见线程不安全的操作：</p>
<ul>
<li><code>i = i+1</code></li>
<li><code>L.append(L[-1])</code></li>
<li><code>L[i] = L[j]</code></li>
<li><code>D[x] = D[x] + 1</code></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创造锁对象</span></span><br><span class="line">lock_object = threading.RLock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加锁（申请一个锁，申请到了就会加锁，没申请到就会等待）</span></span><br><span class="line">lock_object.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放锁（将锁释放出去给别的线程使用）</span></span><br><span class="line">lock_object.release()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解决（t.join()中print结果不为0的问题）</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创造锁对象</span></span><br><span class="line">lock_object = threading.RLock()</span><br><span class="line"></span><br><span class="line">loop = <span class="number">1000000</span></span><br><span class="line">number = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_add</span>(<span class="params">count</span>):</span><br><span class="line">    <span class="comment"># 加锁（申请一个锁，申请到了就会加锁，没申请到就会等待）</span></span><br><span class="line">    lock_object.acquire()</span><br><span class="line">    <span class="keyword">global</span> number</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(loop):</span><br><span class="line">        number += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 释放锁（将锁释放出去给别的线程使用）</span></span><br><span class="line">    lock_object.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_sub</span>(<span class="params">count</span>):</span><br><span class="line">    <span class="comment"># 加锁和释放锁也可以写成with的形式，自动acquire和release</span></span><br><span class="line">    <span class="keyword">with</span> lock_object:</span><br><span class="line">        <span class="keyword">global</span> number</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(loop):</span><br><span class="line">            number -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=_add, args=(loop, ))</span><br><span class="line">t2 = threading.Thread(target=_sub, args=(loop, ))</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">t1.join()  <span class="comment"># t1线程执行完毕,才继续往后走</span></span><br><span class="line">t2.join()  <span class="comment"># t2线程执行完毕,才继续往后走</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(number)  <span class="comment"># 结果一定为0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列表是线程安全的（结果是一定的）</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">data_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">        data_list.append(i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(data_list))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    t = threading.Thread(target=task)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<h4 id="2-4-线程锁"><a href="#2-4-线程锁" class="headerlink" title="2.4 线程锁"></a>2.4 线程锁</h4><blockquote>
<p>在python中，锁有<code>Lock</code>和<code>RLock</code>。它们功能几乎一致，但是在嵌套使用上存在差异。<code>Lock</code>是同步锁，<code>RLock</code>是嵌套锁，也就是说<code>Lock</code>是不支持锁嵌套的，但是<code>RLock</code>可以进行锁的嵌套。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Lock允许的情况</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">lock_object = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">    <span class="comment"># 可以在一个函数中多次锁和多次解锁，不同的线程会进行争锁。</span></span><br><span class="line">    lock_object.acquire()</span><br><span class="line">    <span class="built_in">print</span>(threading.current_thread().name)</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    lock_object.release()</span><br><span class="line"></span><br><span class="line">    lock_object.acquire()</span><br><span class="line">    <span class="built_in">print</span>(threading.current_thread().name)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    lock_object.release()</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    t = threading.Thread(target=task)</span><br><span class="line">    t.start()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Lock不允许的情况（只改task函数）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">    <span class="comment"># 这样会造成死锁，第一个抢到锁的线程会停在第二个acquire()的位置，其他的会停在第一个。</span></span><br><span class="line">    lock_object.acquire()</span><br><span class="line">    <span class="built_in">print</span>(threading.current_thread().name)</span><br><span class="line">    lock_object.acquire()</span><br><span class="line">    <span class="built_in">print</span>(threading.current_thread().name)</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    lock_object.release()</span><br><span class="line">    lock_object.release()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RLock 允许的情况</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">lock_object = threading.RLock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">    <span class="comment"># 可以多次锁和解锁</span></span><br><span class="line">    lock_object.acquire()</span><br><span class="line">    lock_object.acquire()</span><br><span class="line">    <span class="built_in">print</span>(threading.current_thread().name)</span><br><span class="line">    lock_object.release()</span><br><span class="line">    lock_object.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    t = threading.Thread(target=task)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际开发中会遇到的情况</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">lock = threading.RLock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 程序员A写的函数，需要保证线程安全，使用了锁</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 程序员B写的函数，会调用程序员A写的func函数，但不加锁</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;其他功能&quot;</span>)</span><br><span class="line">    func() <span class="comment"># 调用的函数内部存在锁，但此处不会有什么影响</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;其他功能&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 程序员C写的函数，会调用程序员A写的func函数，但需要额外加锁</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>():</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;其他功能&quot;</span>)</span><br><span class="line">        func() <span class="comment"># 此时就会出现多次锁的情况，需要RLock()</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;其他功能&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-5-死锁"><a href="#2-5-死锁" class="headerlink" title="2.5 死锁"></a>2.5 死锁</h4><blockquote>
<p>程序因为锁无法向下进行称为死锁。</p>
<p>死锁的情况：</p>
<ul>
<li>使用Lock两次加锁会导致死锁。因为Lock本身不可以进行嵌套，所以嵌套使用Lock会导致程序卡死。</li>
<li>使用多把锁时，不同线程互相持有对方需要的锁，互相等待对方释放锁，从而造成死锁</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 情况一：使用Lock两次加锁会导致死锁。</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">lock_object = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">    <span class="comment"># 这样会造成死锁，第一个抢到锁的线程会停在第二个acquire()的位置，其他的会停在第一个。</span></span><br><span class="line">    lock_object.acquire()</span><br><span class="line">    <span class="built_in">print</span>(threading.current_thread().name)</span><br><span class="line">    lock_object.acquire()</span><br><span class="line">    <span class="built_in">print</span>(threading.current_thread().name)</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    lock_object.release()</span><br><span class="line">    lock_object.release()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    t = threading.Thread(target=task)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 情况二：多个任务拿多个锁导致卡死</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">lock_1 = threading.Lock()</span><br><span class="line">lock_2 = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># task1拿到1后等待2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task1</span>():</span><br><span class="line">    lock_1.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    lock_2.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">11</span>)</span><br><span class="line">    lock_2.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">111</span>)</span><br><span class="line">    lock_1.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1111</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># task2拿到2后等待1，但因为两个锁都没释放，所以产生了死锁</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task2</span>():</span><br><span class="line">    lock_2.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    lock_1.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">22</span>)</span><br><span class="line">    lock_1.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">222</span>)</span><br><span class="line">    lock_2.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2222</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=task1)</span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">t2 = threading.Thread(target=task2)</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>
<h4 id="2-6-线程池"><a href="#2-6-线程池" class="headerlink" title="2.6 线程池"></a>2.6 线程池</h4><blockquote>
<p>Python3中官方才正式提供线程池。</p>
<p>线程不是开的越多越好，开的多了可能会导致系统的性能更低了。因为线程的上下文切换也需要耗费时间和资源。</p>
<p>不建议：无限制的创建线程。</p>
<p>建议：使用线程池。</p>
<p>在循环中向线程池提交任务时，循环会很快的结束，任务会全部加入到线程池中，但是不是所有任务都会被很快地被执行，而是要看线程池的调度。</p>
<p>案例：</p>
<ol>
<li><p>线程池的使用：会立刻输出END，然后再依次执行子线程任务。因为线程池使用时，线程会立刻被创建完成，然后交给线程池进行调度。</p>
</li>
<li><p>主线程等待线程池工作完毕：加上<code>pool.shutdown(True)</code>会等待子线程执行完再再向下执行。</p>
</li>
<li>执行完任务后，再额外干点别的：加上<code>future.add_done_callback(done)</code>，会在子线程做完操作后再做额外操作。在线程池中，回调是由子线程做的。</li>
<li>最后统一获得结果：将回调结果加入列表中，最后统一来执行回调结果。</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如下的代码是不推荐在项目开发中编写。</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">video_url</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">url_list = [<span class="string">&quot;www.xxxx-&#123;&#125;.com&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30000</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">    t = threading.Thread(target=task, args=(url, ))</span><br><span class="line">    t.start()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 这样每个任务都创建一个线程，线程会特别多，导致效率降低。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 线程池API</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程池，n表示线程池最多有n个线程</span></span><br><span class="line">pool = ThreadPoolExecutor(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向线程池提交一个任务，第一个是函数名，后面的就是参数</span></span><br><span class="line">future = pool.submit(func, para_1, para_2, ... )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待线程池中的任务执行完毕后，主线程才会继续向下进行</span></span><br><span class="line">pool.shutdown(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程执行完后的额外操作</span></span><br><span class="line">future.add_done_callback(func_done)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 线程池示例1：线程池的使用 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">video_url, num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始执行任务&quot;</span>, video_url)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程池，最多维护10个线程</span></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">url_list = [<span class="string">&quot;www.xxx&#123;&#125;.com&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>)]</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">    <span class="comment"># 在线程池中提交一个任务，线程池中如果有空余线程则会分配一个线程去执行，执行完毕后再将线程交还给线程池。如果没有空闲线程则等待。</span></span><br><span class="line">    pool.submit(task, url, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;END&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 线程池案例2：主线程等待线程池工作完毕 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">video_url, num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始执行任务&quot;</span>, video_url)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程池，最多维护10个线程</span></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">url_list = [<span class="string">&quot;www.xxx&#123;&#125;.com&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>)]</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">    <span class="comment"># 在线程池中提交一个任务，线程池中如果有空余线程则会分配一个线程去执行，执行完毕后再将线程交还给线程池。如果没有空闲线程则等待。</span></span><br><span class="line">    pool.submit(task, url, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Wait...&quot;</span>)</span><br><span class="line">pool.shutdown(<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Next...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 线程池案例3：执行完任务后，再额外干点别的&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">video_url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始执行任务&quot;</span>, video_url)</span><br><span class="line">    <span class="comment"># 打印当前线程id</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行任务的线程id:&quot;</span>, threading.current_thread().ident)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> random.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程的返回值是response</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">done</span>(<span class="params">response</span>):</span><br><span class="line">    <span class="comment"># 通过response.result()拿到返回值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务执行后的返回值&quot;</span>, response.result())</span><br><span class="line">    <span class="comment"># 打印回调函数的线程id</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;回调函数的线程id:&quot;</span>, threading.current_thread().ident)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">url_list = [<span class="string">&quot;www.xxx&#123;&#125;.com&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)]</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">    future = pool.submit(task, url)</span><br><span class="line">    future.add_done_callback(done)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot; 线程池案例4：最后统一获得结果 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">video_url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始执行任务&quot;</span>, video_url)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> random.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建列表</span></span><br><span class="line">future_list = []</span><br><span class="line"></span><br><span class="line">url_list = [<span class="string">&quot;www.xxx&#123;&#125;.com&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)]</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">    future = pool.submit(task, url)</span><br><span class="line">    future_list.append(future)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等线程都完成工作，再循环做后续操作</span></span><br><span class="line">pool.shutdown(<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> fu <span class="keyword">in</span> future_list:</span><br><span class="line">    <span class="built_in">print</span>(fu.result())</span><br></pre></td></tr></table></figure>
<h4 id="2-7-单例模式"><a href="#2-7-单例模式" class="headerlink" title="2.7 单例模式"></a>2.7 单例模式</h4><blockquote>
<p>多线程单例模式下，因为线程之间的交换，所以可能会导致单例模式创造出来的不是一个单例。</p>
<p>为了解决问题则需要加锁。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 会引发问题的单例模式</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>:</span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls.instance:</span><br><span class="line">            <span class="keyword">return</span> cls.instance</span><br><span class="line">        <span class="comment"># 加上time.sleep(0.1)模拟线程停在此处</span></span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        cls.instance = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    obj = Singleton(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=task)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加锁解决问题</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>:</span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    lock = threading.RLock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls.instance:</span><br><span class="line">            <span class="keyword">return</span> cls.instance</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">with</span> cls.lock:</span><br><span class="line">            <span class="keyword">if</span> cls.instance:</span><br><span class="line">                <span class="keyword">return</span> cls.instance</span><br><span class="line">            cls.instance = <span class="built_in">object</span>.__new__(cls)</span><br><span class="line">            <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    obj = Singleton(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=task)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<h3 id="3-多进程开发"><a href="#3-多进程开发" class="headerlink" title="3 多进程开发"></a>3 多进程开发</h3><h4 id="3-1-进程定义"><a href="#3-1-进程定义" class="headerlink" title="3.1 进程定义"></a>3.1 进程定义</h4><blockquote>
<p>进程是计算机中资源分配的最小单元。一个进程中可以有多个线程，同一个进程中的线程共享资源。</p>
<p>进程与进程之间则是相互隔离。</p>
<p>Python中通过多进程可以利用CPU的多核优势，</p>
<p>多进程适用于计算密集型，例如∶大量的数据计算【累加计算示例】。</p>
<p>创建进程模式：</p>
<ul>
<li><code>fork</code>：”拷贝”几乎所有的资源，支持文件对象 / 线程锁传参，用于unix，可以在代码中任意位置开始，操作较快。</li>
<li><code>spawn</code>：相当于在内部线创建一个python解释器，然后让解释器执行代码，不支持文件对象 / 线程锁传参，用于unix、win，必须从main代码块开始，操作较慢。</li>
<li><code>forkserver</code>：在程序开始前会把多进程部分当做模版加载，然后在启动时会找到模板，拷贝一份执行。不支持文件对象 / 线程锁传参，用于部分unix，必须从main代码块开始。</li>
</ul>
<p>注：Linux系统使用fork创建进程，Windows使用spawn，Mac支持fork和spawn。在python3.8版本后默认使用spawn创建线程，所以程序会要求创建线程代码必须在<code>if __name__ == &#39;__main__&#39;:</code>下，否则会异常。</p>
<p>mac中可以修改创建线程使用的方式来避免改变创建方式。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="comment"># mac可以修改创建方式来改变创建方式（写在程序开头位置）</span></span><br><span class="line"><span class="comment"># multiprocessing.set_start_method(&#x27;fork&#x27;)</span></span><br><span class="line"></span><br><span class="line">url_list = &#123;</span><br><span class="line">    (<span class="string">&quot;1.mp4&quot;</span>, <span class="string">&quot;https://www.xxx.com/?id=1&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;2.mp4&quot;</span>, <span class="string">&quot;https://www.xxx.com/?id=2&quot;</span>),</span><br><span class="line">    (<span class="string">&quot;3.mp4&quot;</span>, <span class="string">&quot;https://www.xxx.com/?id=3&quot;</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">file_name, video_url</span>):</span><br><span class="line">    res = requests.get(video_url)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(res.content)</span><br><span class="line">    <span class="built_in">print</span>(time.time())</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows下必须放在main中（也可以写成一个函数，只要是在__main__下启动即可）</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> name, url <span class="keyword">in</span> url_list:</span><br><span class="line">        t = multiprocessing.Process(target=task, args=(name, url))</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; fork案例（仅限unix） &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例1：子进程改变不影响主进程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="comment"># 拿到主进程的空列表后改变空列表</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    name.append(<span class="number">123</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;fork&quot;</span>)</span><br><span class="line">    name = []</span><br><span class="line">    </span><br><span class="line">    p1 = multiprocessing.Process(target=task)</span><br><span class="line">    p1.start()</span><br><span class="line">    </span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 返回的是空，子进程是拷贝，不会对主进程有影响</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例2：子进程拿到的是主进程创建子进程前的数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="comment"># 拿到主进程的[123]列表</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;fork&quot;</span>)</span><br><span class="line">    name = []</span><br><span class="line">    name.append(<span class="number">123</span>)</span><br><span class="line">    </span><br><span class="line">    p1 = multiprocessing.Process(target=task)</span><br><span class="line">    p1.start()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 案例3：主改变不影响子</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="comment"># 拿到主进程的空列表，主进程的name改变了也不影响子进程的name</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;fork&quot;</span>)</span><br><span class="line">    name = []</span><br><span class="line">    </span><br><span class="line">    p1 = multiprocessing.Process(target=task)</span><br><span class="line">    p1.start()</span><br><span class="line">    </span><br><span class="line">    name.append(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; spawn案例 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例1：子进程不会直接拿到主进程的数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="comment"># 直接异常，提示没有name</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;spawn&quot;</span>)</span><br><span class="line">    name = []   </span><br><span class="line">    </span><br><span class="line">    p1 = multiprocessing.Process(target=task)</span><br><span class="line">    p1.start()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 案例2：传递参数就不会报错</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="comment"># 子进程拿到data后会拷贝一份给子进程用</span></span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    data.append(<span class="number">999</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;spawn&quot;</span>)</span><br><span class="line">    name = []   </span><br><span class="line">    </span><br><span class="line">    p1 = multiprocessing.Process(target=task, args=(name,))</span><br><span class="line">    p1.start()</span><br><span class="line">    </span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># name输出空，子进程和主进程用的是不同的数据</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; fork和spwan传递资源的区别 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># fork：可以直接传递文件和锁</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">fb</span>):</span><br><span class="line">    <span class="comment"># 可以直接传递也可以不传递</span></span><br><span class="line">    <span class="built_in">print</span>(fb, lock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;fork&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    name = []</span><br><span class="line">    file_object = <span class="built_in">open</span>(<span class="string">&quot;1.txt&quot;</span>, mode=<span class="string">&quot;a+&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    lock = threading.RLock()</span><br><span class="line">    </span><br><span class="line">    p1 = multiprocessing.Process(target=task, args=(file_object,))</span><br><span class="line">    p1.start()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># spwan：不可以传递文件和锁</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">fb, lk</span>):</span><br><span class="line">    <span class="comment"># 会直接报错</span></span><br><span class="line">    <span class="built_in">print</span>(fb, lk)</span><br><span class="line">    <span class="comment"># 正确方式是在子进程中重新创建一遍</span></span><br><span class="line">    <span class="comment"># file_object = open(&quot;1.txt&quot;, mode=&quot;a+&quot;, encoding=&quot;utf-8&quot;)</span></span><br><span class="line">    <span class="comment"># lock = threading.RLock()</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;fork&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    name = []</span><br><span class="line">    file_object = <span class="built_in">open</span>(<span class="string">&quot;1.txt&quot;</span>, mode=<span class="string">&quot;a+&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    lock = threading.RLock()</span><br><span class="line">    </span><br><span class="line">    p1 = multiprocessing.Process(target=task, args=(file_object, lock, ))</span><br><span class="line">    p1.start()</span><br></pre></td></tr></table></figure>
<h4 id="3-2-进程案例"><a href="#3-2-进程案例" class="headerlink" title="3.2 进程案例"></a>3.2 进程案例</h4><blockquote>
<p>案例1：</p>
<ul>
<li>操作：主进程和子进程都进行文件操作。</li>
<li>结果：武沛齐 alex 武沛齐</li>
<li>原因：子进程拷贝主进程，所以一开时子进程有武沛齐，然后又写入了alex，之后<code>flush()</code>一下，此时文件中就有了武沛齐和alex。又因为主进程再等着子进程，主进程的武沛齐一开始没有写入到文件中，当子进程结束后，主进程结束，此时武沛齐才写入到文件中，所以会出现上述结果。前两个单词是子进程写的，后一个单词是主进程写的。</li>
</ul>
<p>案例2：</p>
<ul>
<li>操作：主进程在案例1的基础上先<code>flush()</code>一下。</li>
<li>结果：武沛齐 alex</li>
<li>原因：主进程写入后因为直接进行了<code>flush()</code>，所以直接就先把武沛齐写到文件中了，此时传给子进程的缓存内容是空，所以子进程只会再额外写入alex。此时前一个单词是主进程写的，后一个单词是子进程写的。</li>
</ul>
<p>案例3：</p>
<ul>
<li>操作：主进程加锁后传递给子进程。</li>
<li>结果：<code>&lt;locked ... &gt;</code>666</li>
<li>原因：主进程加锁后传递给子进程，子进程拿到锁后，一样是锁的状态，只不过在子进程的锁的对象是子进程中的主线程，而主进程的锁的对象是主进程中的主线程。因为此时锁是<code>RLock()</code>，所以可以进行嵌套锁，所以666会被输出在屏幕上。</li>
</ul>
<p>案例4：</p>
<ul>
<li>操作：子进程中创建子线程。</li>
<li>结果：先输出十个”来了”，等2秒后依次输出666。</li>
<li>原因：由案例3可知，因为一开始锁就是锁的状态，然后子进程中锁的作用对象是主线程，所以一开始子进程中的子线程全都会卡主，当子进程的主线程的锁释放后，子进程的子线程才会依次开始执行。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 案例1：文件操作</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    file_object.write(<span class="string">&quot;alex\n&quot;</span>)</span><br><span class="line">    file_object.flush()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;fork&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    name = []</span><br><span class="line">    file_object = <span class="built_in">open</span>(<span class="string">&#x27;x1.txt&#x27;</span>, mode=<span class="string">&#x27;a+&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    file_object.write(<span class="string">&quot;武沛齐\n&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    p1 = multiprocessing.Process(target=task)</span><br><span class="line">    p1.start()</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"><span class="comment"># 案例2：在案例1的基础上只在主进程中加一次flush()</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    file_object.write(<span class="string">&quot;alex\n&quot;</span>)</span><br><span class="line">    file_object.flush()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;fork&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    name = []</span><br><span class="line">    file_object = <span class="built_in">open</span>(<span class="string">&#x27;x1.txt&#x27;</span>, mode=<span class="string">&#x27;a+&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    file_object.write(<span class="string">&quot;武沛齐\n&quot;</span>)</span><br><span class="line">    <span class="comment"># 新增代码</span></span><br><span class="line">    file_object.flush()</span><br><span class="line">    </span><br><span class="line">    p1 = multiprocessing.Process(target=task)</span><br><span class="line">    p1.start()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 案例3：锁操作</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="built_in">print</span>(lock)</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">666</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;fork&quot;</span>)</span><br><span class="line">    name = []</span><br><span class="line">    lock = threading.RLock()</span><br><span class="line">    lock.acquire()</span><br><span class="line">    </span><br><span class="line">    p1 = multiprocessing.Process(target=task)</span><br><span class="line">    p1.start()</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 案例4：子进程创建子线程（main同案例3）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;来了&quot;</span>)</span><br><span class="line">	<span class="keyword">with</span> lock:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">666</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        t = threading.Thread(target=func)</span><br><span class="line">        t.start()</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    lock.release()</span><br></pre></td></tr></table></figure>
<h4 id="3-3-进程API"><a href="#3-3-进程API" class="headerlink" title="3.3 进程API"></a>3.3 进程API</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置创建子进程的模式（&#x27;fork&#x27;、&#x27;spawn&#x27;）</span></span><br><span class="line">multiprocessing.set_start_method(<span class="string">&quot;fork&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建子进程（函数名，参数）</span></span><br><span class="line">p = multiprocessing.Process(target=task, args=(<span class="string">&quot;xxx&quot;</span>, ))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动子进程</span></span><br><span class="line">p.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待子进程执行完毕再向下执行</span></span><br><span class="line">p.join()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置守护进程（必须放在start前）</span></span><br><span class="line"><span class="comment"># 守护进程，主进程执行完后子进程也关闭</span></span><br><span class="line">p.daemon = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 非守护进程，主进程等待子进程执行完毕后，主进程才关闭（默认）</span></span><br><span class="line">p.daemon = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置名字</span></span><br><span class="line">p.name = <span class="string">&quot;进程1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取名字</span></span><br><span class="line">multiprocessing.current_process().name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看CPU个数（一般cpu有几个就创建几个子进程）</span></span><br><span class="line">multiprocessing.cpu_count()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 补充知识 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 获得当前进程id</span></span><br><span class="line">os.getpid()</span><br><span class="line"><span class="comment"># 获得父进程id</span></span><br><span class="line">os.getppid()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="comment"># 获取进程里所有线程，存入列表中</span></span><br><span class="line">lst = threading.<span class="built_in">enumerate</span>()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义线程类</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyProcess</span>(multiprocessing.Process):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 获得参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;执行次线程&quot;</span>, self._args)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;spawn&quot;</span>)</span><br><span class="line">    p = MyProcess(args=(<span class="string">&quot;xxx&quot;</span>, ))</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;继续执行...&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="3-4-数据共享"><a href="#3-4-数据共享" class="headerlink" title="3.4 数据共享"></a>3.4 数据共享</h4><blockquote>
<p>默认情况下进程之间的资源是独立的，不进行共享。</p>
<p>如果要让他们之间进行共享，需要借助特殊方式实现。</p>
<p>特殊方式：</p>
<ul>
<li>使用<code>Value</code>和<code>Array</code>。通过这两者创建的数据可以进行共享。但是因为是比较底层，所以使用较少。</li>
<li>使用<code>Manager()</code>。通过<code>Manager()</code>创建的数据类型，可以进行共享。因为可以用python语法，使用较舒服。</li>
<li>使用<code>multiprocessing.Queue()</code>。就是一个队列，只不过这个队列可以实现资源共享，且不会数据混乱。使用较多。</li>
<li>使用<code>multiprocessing.Pipe()</code>。双端队列，可以双向通信，资源共享，且不会数据混乱。使用较多。</li>
</ul>
<p>上述都是Python内部提供的进程之间数据共享和交换的机制，作为了解即可，在项目开发中很少使用，后期项目中一般会借助第三方的来做资源的共享，例如：MySQL，Redis等。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>value参数</th>
<th>代表的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c</code></td>
<td><code>ctypes.c_char</code></td>
</tr>
<tr>
<td><code>b</code></td>
<td><code>ctypes.c_byte</code></td>
</tr>
<tr>
<td><code>h</code></td>
<td><code>ctypes.c_short</code></td>
</tr>
<tr>
<td><code>i</code></td>
<td><code>ctypes.c_int</code></td>
</tr>
<tr>
<td><code>l</code></td>
<td><code>ctypes.c_long</code></td>
</tr>
<tr>
<td><code>f</code></td>
<td><code>ctypes.c_float</code></td>
</tr>
<tr>
<td><code>u</code></td>
<td><code>ctypes.c_wchar</code></td>
</tr>
<tr>
<td><code>B</code></td>
<td><code>ctypes.c_ubyte</code></td>
</tr>
<tr>
<td><code>H</code></td>
<td><code>ctypes.c_ushort</code></td>
</tr>
<tr>
<td><code>I</code></td>
<td><code>ctypes.c_uint</code></td>
</tr>
<tr>
<td><code>L</code></td>
<td><code>ctypes.c_ulong</code></td>
</tr>
<tr>
<td><code>d</code></td>
<td><code>ctypes.c_double</code></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; Value和Array方式 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Value, Array</span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例1：普通数据操作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">n, m1, m2</span>):</span><br><span class="line">    n.value = <span class="number">888</span></span><br><span class="line">    m1.value = <span class="string">&#x27;a&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    m2.value = <span class="string">&#x27;武&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 设置类型，默认值</span></span><br><span class="line">    num = Value(<span class="string">&#x27;i&#x27;</span>, <span class="number">666</span>)</span><br><span class="line">    v1 = Value(<span class="string">&#x27;c&#x27;</span>, <span class="string">b&#x27; &#x27;</span>)</span><br><span class="line">    v2 = Value(<span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p = Process(target=func, args=(num, v1, v2))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(num.value)  <span class="comment"># 888</span></span><br><span class="line">    <span class="built_in">print</span>(v1.value)  <span class="comment"># b&#x27;a&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(v2.value)  <span class="comment"># 武</span></span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 案例2：数组数据操作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">data_array</span>):</span><br><span class="line">    data_array[<span class="number">0</span>] = <span class="number">666</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建数组，就是C语言的数组（固定类型和长度）</span></span><br><span class="line">    arr = Array(<span class="string">&#x27;i&#x27;</span>, [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>])</span><br><span class="line">    </span><br><span class="line">    p = Process(target=f, args=(arr,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(arr[:])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; Manager()方式 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Manager</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">d, l</span>):</span><br><span class="line">    d[<span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    d[<span class="string">&#x27;2&#x27;</span>] = <span class="number">2</span></span><br><span class="line">    d[<span class="number">0.25</span>] = <span class="literal">None</span></span><br><span class="line">    l.append(<span class="number">666</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">with</span> Manager() <span class="keyword">as</span> manager:</span><br><span class="line">        d = manager.<span class="built_in">dict</span>()</span><br><span class="line">        l = manager.<span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">        p = Process(target=f, args=(d, l))</span><br><span class="line">        p.start()</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(d)</span><br><span class="line">        <span class="built_in">print</span>(l)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; Queue()方式 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子进程任务函数，将数据放入队列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        q.put(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建一个多进程安全的队列</span></span><br><span class="line">    queue = multiprocessing.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建子进程并传入队列作为参数</span></span><br><span class="line">    p = multiprocessing.Process(target=task, args=(queue,))</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待子进程完成</span></span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主进程中从队列中获取数据并打印</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;主进程开始获取数据：&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(queue.get())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; Pipe()方式 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义子进程任务函数，通过管道与主进程通信</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">child_conn</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    child_conn.send([<span class="number">111</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>])  <span class="comment"># 子进程发送数据</span></span><br><span class="line">    data = child_conn.recv()  <span class="comment"># 阻塞，等待接收主进程发送的数据</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;子进程接收:&quot;</span>, data)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建一个管道，返回一对连接对象，一个是父进程端（parent_conn），另一个是子进程端（child_conn）</span></span><br><span class="line">    parent_conn, child_conn = multiprocessing.Pipe()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建子进程并传入子进程端的连接对象</span></span><br><span class="line">    p = multiprocessing.Process(target=task, args=(child_conn,))</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主进程接收子进程发送的数据</span></span><br><span class="line">    info = parent_conn.recv()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;主进程接收:&quot;</span>, info)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主进程向子进程发送数据</span></span><br><span class="line">    parent_conn.send(<span class="number">666</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为了保证子进程能顺利完成任务，这里应等待子进程结束后再结束主进程</span></span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>
<h4 id="3-5-进程锁"><a href="#3-5-进程锁" class="headerlink" title="3.5 进程锁"></a>3.5 进程锁</h4><blockquote>
<p>进程锁：使用类似于线程锁，但是线程锁不能作为参数传递到子进程中，而进程锁是可以传递到子进程中的。</p>
<p>spawn模式下，在主进程的结尾处需要做一些特殊的处理，不然可能会报错：</p>
<ul>
<li>使用<code>time.sleep(7)</code>等待7秒。</li>
<li>使用<code>p.join()</code>，主进程等待所有子进程完成后再向下。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">lock</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">    lock.acquire()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取文件中的值</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;f1.txt&#x27;</span>, mode=<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        current_num = <span class="built_in">int</span>(f.read())</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;排队抢票了&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    current_num -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新文件中的值</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;f1.txt&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="built_in">str</span>(current_num))</span><br><span class="line"></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># spawn模式下特殊处理方法1</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;spawn&quot;</span>)</span><br><span class="line">    <span class="comment"># 进程锁，可以作为参数传递给子进程</span></span><br><span class="line">    lock = multiprocessing.RLock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p = multiprocessing.Process(target=task, args=(lock,))</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process_list:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 等待7秒</span></span><br><span class="line">    time.sleep(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    multiprocessing.set_start_method(<span class="string">&quot;spawn&quot;</span>)</span><br><span class="line">    <span class="comment"># 进程锁，可以作为参数传递给子进程</span></span><br><span class="line">    lock = multiprocessing.RLock()</span><br><span class="line"></span><br><span class="line">    process_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p = multiprocessing.Process(target=task, args=(lock,))</span><br><span class="line">        p.start()</span><br><span class="line">        process_list.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 依次等待任务执行完毕</span></span><br><span class="line">	<span class="keyword">for</span> item <span class="keyword">in</span> process_list:</span><br><span class="line">        item.join()</span><br></pre></td></tr></table></figure>
<h4 id="3-6-进程池"><a href="#3-6-进程池" class="headerlink" title="3.6 进程池"></a>3.6 进程池</h4><blockquote>
<p>案例：</p>
<ol>
<li><p>线程池的使用：会立刻输出1，然后再依次执行子进程任务。因为进程池使用时，进程会立刻被创建完成，然后交给进程池进行调度。</p>
</li>
<li><p>主线程等待线程池工作完毕：加上<code>pool.shutdown(True)</code>，会等待子进程执行完再再向下执行。</p>
</li>
<li>执行完任务后，再额外干点别的：加上<code>fur.add_done_callback(done)</code>，会在子进程做完操作后再做额外操作，但是此处和线程池有区别。进程池中的回调都是由主进程进行操作。</li>
<li>在子进程中使用进程锁：在进程池中加锁，需要用到<code>Manager()</code>中的<code>Lock()</code>和<code>RLock()</code>，不能使用自带的进程锁。因为在<code>multiprocessing</code>模块中，每个进程都有自己独立的内存空间，因此无法直接共享普通的线程锁，而<code>Manager()</code>中的<code>Lock()</code>和<code>RLock()</code>是专门为进程间通信设计的锁，所以应该使用<code>Manager()</code>中的进程锁。</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进程池API</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建进程池，n表示进程池最多有n个进程</span></span><br><span class="line">pool = ProcessPoolExecutor(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向进程池提交一个任务，第一个是函数名，后面的就是参数</span></span><br><span class="line">future = pool.submit(func, para_1, para_2, ... )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待进程池中的任务执行完毕后，主线程才会继续向下进行</span></span><br><span class="line">pool.shutdown(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程执行完后的额外操作</span></span><br><span class="line">future.add_done_callback(func_done)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回调函数传参（利用闭包）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">info, file_name</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">done</span>(<span class="params">res, *args, **kwargs</span>):</span><br><span class="line">        info[file_name] = res.result()</span><br><span class="line">    <span class="keyword">return</span> done</span><br><span class="line">fur.add_done_callback(outer(info, file_name))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 线程池示例1：线程池的使用 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor, ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行&quot;</span>, num)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        pool.submit(task, i)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 线程池案例2：主线程等待线程池工作完毕 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor, ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行&quot;</span>, num)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        pool.submit(task, i)</span><br><span class="line"></span><br><span class="line">    pool.shutdown(<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 或者用with也能实现相同功能</span></span><br><span class="line">    <span class="comment"># with ProcessPoolExecutor(4) as pool:</span></span><br><span class="line">    <span class="comment">#     for i in range(10):</span></span><br><span class="line">    <span class="comment">#         pool.submit(task, i)</span></span><br><span class="line">    <span class="comment"># print(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 线程池案例3：执行完任务后，再额外干点别的&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行&quot;</span>, num)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">done</span>(<span class="params">res</span>):</span><br><span class="line">    <span class="comment"># 发现是主进程在做操作</span></span><br><span class="line">    <span class="built_in">print</span>(multiprocessing.current_process())</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 通过res.result()拿到返回值</span></span><br><span class="line">    <span class="built_in">print</span>(res.result())</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">        fur = pool.submit(task, i)</span><br><span class="line">        fur.add_done_callback(done)  <span class="comment"># done的调用由主进程处理(与线程池不同)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(multiprocessing.current_process())</span><br><span class="line">    pool.shutdown(<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 线程池案例4：在子进程中使用进程锁 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">lock</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不能使用</span></span><br><span class="line">    <span class="comment"># lock.acquire()</span></span><br><span class="line">    <span class="comment"># lock.release()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="comment"># 假设文件中保存的内容就是一个值：10</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;f1.txt&#x27;</span>, mode=<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            current_num = <span class="built_in">int</span>(f.read())</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;排队抢票了&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        current_num -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 更新文件中的值</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;f1.txt&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="built_in">str</span>(current_num))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = ProcessPoolExecutor()</span><br><span class="line">    <span class="comment"># 不能使用这个进程锁</span></span><br><span class="line">    <span class="comment"># lock_object = multiprocessing.RLock()</span></span><br><span class="line">    manager = multiprocessing.Manager()</span><br><span class="line">    lock_object = manager.RLock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        pool.submit(task, lock_object)</span><br></pre></td></tr></table></figure>
<h4 id="3-7-多进程案例"><a href="#3-7-多进程案例" class="headerlink" title="3.7 多进程案例"></a>3.7 多进程案例</h4><blockquote>
<p>要求：统计日志文件中的数据量和ip种数。</p>
<p>数据存在<code>files</code>文件夹下，格式：<code>127.0.0.1 - - [21/Mar/2021] &quot;GET&quot; ......</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">file_name</span>):</span><br><span class="line">    ip_set = <span class="built_in">set</span>()</span><br><span class="line">    total_count = ip_count = <span class="number">0</span></span><br><span class="line">    file_path = os.path.join(<span class="string">&quot;files&quot;</span>, file_name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, mode=<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file_object:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> line.strip():</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            user_ip = line.split(<span class="string">&quot; - -&quot;</span>, maxsplit=<span class="number">1</span>)[<span class="number">0</span>].split(<span class="string">&quot;, &quot;</span>)[<span class="number">0</span>]</span><br><span class="line">            total_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> user_ip <span class="keyword">in</span> ip_set:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            ip_count += <span class="number">1</span></span><br><span class="line">            ip_set.add(user_ip)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;total&quot;</span>: total_count, <span class="string">&#x27;ip&#x27;</span>: ip_count&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">info, file_name</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">done</span>(<span class="params">res, *args, **kwargs</span>):</span><br><span class="line">        info[file_name] = res.result()</span><br><span class="line">    <span class="keyword">return</span> done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="comment"># 根据目录读取文件并初始化字典</span></span><br><span class="line">    info = &#123;&#125;</span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> os.listdir(<span class="string">&quot;files&quot;</span>):</span><br><span class="line">        fur = pool.submit(task, file_name)</span><br><span class="line">        fur.add_done_callback(outer(info, file_name))</span><br><span class="line"></span><br><span class="line">    pool.shutdown(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> info.items():</span><br><span class="line">        <span class="built_in">print</span>(k, v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-协程"><a href="#4-协程" class="headerlink" title="4 协程"></a>4 协程</h3><h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h4><blockquote>
<p>了解为主。</p>
<p>计算机中提供了：线程、进程用于实现并发编程（真实存在）。</p>
<p>协程（Coroutine），是程序员通过代码搞出来的一个东西（非真实存在）。</p>
<p>协程也可以被称为微线程，是一种用户态内的上下文切换技术。</p>
<p>简而言之，其实就是通过一个线程实现代码块相互切换执行（来回跳着执行）。</p>
<p>下列greenlet和yield可以模拟协程，但是一般不这么使用。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用greenlet模拟协程（pip install greenlet）</span></span><br><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)  <span class="comment"># 2.输出1</span></span><br><span class="line">    gr2.switch()  <span class="comment"># 3.切换到func2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)  <span class="comment"># 6.输出2</span></span><br><span class="line">    gr2.switch()  <span class="comment"># 7.切换到func2，从上一次执行位置向后执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)  <span class="comment"># 2.输出3</span></span><br><span class="line">    gr1.switch()  <span class="comment"># 2.切换到func1，从上一次执行位置向后执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)  <span class="comment"># 2.输出4</span></span><br><span class="line"></span><br><span class="line">gr1 = greenlet(func1)</span><br><span class="line">gr2 = greenlet(func2)</span><br><span class="line">gr1.switch()  <span class="comment"># 1.执行func1函数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yield模拟协程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> func2()</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = func1()</span><br><span class="line"><span class="comment"># 输出结果是1 3 4 2</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> f1:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>
<h4 id="4-2-asyncio"><a href="#4-2-asyncio" class="headerlink" title="4.2 asyncio"></a>4.2 asyncio</h4><blockquote>
<p>协程如何才能更有意义呢：不要让用户手动去切换，而是遇到IO操作时能自动切换。</p>
<p>Python在3.4之后推出了<code>asyncio</code>模块＋ Python3.5推出<code>async</code>、<code>async</code>语法，内部基于协程并且遇到IO请求自动化切换。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># asyncio的API</span></span><br><span class="line"><span class="comment"># async定义一个协程</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line"></span><br><span class="line"><span class="comment"># await用来挂起阻塞方法的执行</span></span><br><span class="line"><span class="keyword">await</span> func();</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阻塞n秒</span></span><br><span class="line">asyncio.sleep(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个任务（Task）并立即运行</span></span><br><span class="line">asyncio.ensure_future(func1())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化事件循环</span></span><br><span class="line">loop = asyncio.new_event_loop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置时间循环</span></span><br><span class="line">asyncio.set_event_loop(loop)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取事件循环</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待多个协程任务完成</span></span><br><span class="line">asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行事件循环，直到完成所有任务</span></span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># asyncio案例</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future(func1()),</span><br><span class="line">    asyncio.ensure_future(func2())</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>
<h4 id="4-3-aiohttp案例"><a href="#4-3-aiohttp案例" class="headerlink" title="4.3 aiohttp案例"></a>4.3 aiohttp案例</h4><blockquote>
<p>利用协程来爬取图片。</p>
<p>需要先安装<code>aiohttp</code>。</p>
<p>实际使用中，一般不在协程中做数据处理，而是只负责获取数据，获取的数据直接放到队列、文件或数据库里。</p>
<p>后续学习：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/137057192">asyncio异步编程，你搞懂了吗？ - 知乎 (zhihu.com)</a></p>
<p>后续学习：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1NA411g7yf/?vd_source=b9521fbd84454f03eb78189e6ea6f9e6">asyncio到底是个啥？【python async await】_哔哩哔哩_bilibili</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">download_image</span>(<span class="params">session, url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;开始下载: <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, verify_ssl=<span class="literal">False</span>) <span class="keyword">as</span> response:</span><br><span class="line">        content = <span class="keyword">await</span> response.content.read()</span><br><span class="line">        <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">save_image</span>(<span class="params">content, filename</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;开始保存: <span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">        file_object.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_and_save</span>(<span class="params">session, url</span>):</span><br><span class="line">    <span class="comment"># 下载图片</span></span><br><span class="line">    content = <span class="keyword">await</span> download_image(session, url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析 URL 并提取文件名</span></span><br><span class="line">    parsed_url = urllib.parse.urlparse(url)</span><br><span class="line">    path_parts = parsed_url.path.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    file_name = path_parts[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果原始 URL 末尾没有文件扩展名，则加上预设的 .jpg 扩展名</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> file_name:</span><br><span class="line">        file_name += <span class="string">&quot;.jpg&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存图片到本地</span></span><br><span class="line">    <span class="keyword">await</span> save_image(content, file_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        url_list = [</span><br><span class="line">            <span class="string">&#x27;https://gitcode.net/qq_44112897/images/-/raw/master/comic/25.jpg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://gitcode.net/qq_44112897/images/-/raw/master/comic/26.jpg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://gitcode.net/qq_44112897/images/-/raw/master/comic/27.jpg&#x27;</span></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        tasks = [asyncio.create_task(fetch_and_save(session, url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    loop = asyncio.new_event_loop()</span><br><span class="line">    asyncio.set_event_loop(loop)</span><br><span class="line">    loop.run_until_complete(main())</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://Magialeaf.github.io">Maigaleaf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://magialeaf.github.io/posts/bce7e83e.html">http://magialeaf.github.io/posts/bce7e83e.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://Magialeaf.github.io" target="_blank">Magialeaf的小窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A6%82%E8%BF%B0/">概述</a><a class="post-meta__tags" href="/tags/python/">python</a><a class="post-meta__tags" href="/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/">程序语言</a></div><div class="post_share"><div class="social-share" data-image="/img/default_cover_3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/19bd9e59.html" title="selenium模块"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_8.png" onerror="onerror=null;src='/img/error.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">selenium模块</div></div></a></div><div class="next-post pull-right"><a href="/posts/208f8371.html" title="Websocket"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_14.png" onerror="onerror=null;src='/img/error.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Websocket</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/c386cf1b.html" title="Python爬虫"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_4.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-03-26</div><div class="title">Python爬虫</div></div></a></div><div><a href="/posts/a378bd8e.html" title="Python"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_2.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-05-07</div><div class="title">Python</div></div></a></div><div><a href="/posts/9ad5026b.html" title="区块链技术"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_12.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-01-05</div><div class="title">区块链技术</div></div></a></div><div><a href="/posts/251c2987.html" title="C++游戏"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_2.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-11-29</div><div class="title">C++游戏</div></div></a></div><div><a href="/posts/f19f4a3.html" title="Opencv"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_15.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-01-05</div><div class="title">Opencv</div></div></a></div><div><a href="/posts/9add283d.html" title="Python_AI"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_4.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-01-05</div><div class="title">Python_AI</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Maigaleaf</div><div class="author-info__description">欢迎来到我的小窝！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">59</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Magialeaf"><i class="fab fa-github"></i><span>前往我的仓库</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://res.abeim.cn/api/qq?qq=1871154309" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="https://space.bilibili.com/45054712" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_51591267" target="_blank" title="CSDN"><i class="fa-solid fa-c" style="color: ;"></i></a><a class="social-icon" href="https://leetcode.cn/u/heuristic-chandrasekhardtz/" target="_blank" title="leetcode"><i class="fas fa-code"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><card_announce_top>当前网站版本为V1.03<br /></card_announce_top> <card_announce_content> 1.网站目前文章多为思维导图，类似随笔，记录比较简略。<br /> 2.之后会完善一些未写完的文章，以及写一些详细的文章。<br /> 3.找文章推荐在分类中按<a href="/categories/" class="strong">分类</a>寻找。 <br /> 4.每日更新以及网站更新可以在<a href="/about/" class="strong">关于</a>中查看。<br /><br /> </card_announce_content> <card_announce_tip> 文章链接为紫色，链接前缀如下：<br /> &nbsp; 1.无前缀（百科或其他作者的链接）<br /> &nbsp; 2.author::（文章中引用了许多该作者的内容）<br /> &nbsp; 3.official::（官网链接）<br /> &nbsp; 4.text::（我的其他文本）<br /> &nbsp; 5.my::（我的库或其他链接）<br /> </card_announce_tip></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Python%E9%AB%98%E7%BA%A7"><span class="toc-text">Python高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">一、内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">1 内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%8E%AF%E7%8A%B6%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">1.1 环状双向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">1.2 具体类型结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-text">1.3 引用计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-text">1.4 循环引用问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="toc-text">2 标记清除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-text">3 分代回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-text">4 缓存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%80%BB%E7%BB%93"><span class="toc-text">4.1 总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E6%B1%A0"><span class="toc-text">4.2 池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-free-list"><span class="toc-text">4.3 free_list</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-text">5 源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-float-%E7%B1%BB%E5%9E%8B"><span class="toc-text">5.1 float 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-list-%E7%B1%BB%E5%9E%8B"><span class="toc-text">5.2 list 类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">二、多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">1 进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">1.1 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.2 多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-text">1.3 多进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-GIL%E9%94%81"><span class="toc-text">1.4 GIL锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91"><span class="toc-text">2 多线程开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%B8%B8%E8%A7%81API"><span class="toc-text">2.1 常见API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-API%E4%BD%BF%E7%94%A8"><span class="toc-text">2.2 API使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">2.3 线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="toc-text">2.4 线程锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E6%AD%BB%E9%94%81"><span class="toc-text">2.5 死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">2.6 线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.7 单例模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%BC%80%E5%8F%91"><span class="toc-text">3 多进程开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E8%BF%9B%E7%A8%8B%E5%AE%9A%E4%B9%89"><span class="toc-text">3.1 进程定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E8%BF%9B%E7%A8%8B%E6%A1%88%E4%BE%8B"><span class="toc-text">3.2 进程案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E8%BF%9B%E7%A8%8BAPI"><span class="toc-text">3.3 进程API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-text">3.4 数据共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E8%BF%9B%E7%A8%8B%E9%94%81"><span class="toc-text">3.5 进程锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="toc-text">3.6 进程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A1%88%E4%BE%8B"><span class="toc-text">3.7 多进程案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8D%8F%E7%A8%8B"><span class="toc-text">4 协程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%AE%9A%E4%B9%89"><span class="toc-text">4.1 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-asyncio"><span class="toc-text">4.2 asyncio</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-aiohttp%E6%A1%88%E4%BE%8B"><span class="toc-text">4.3 aiohttp案例</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/62e0b2c0.html" title="Celery"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_3.png" onerror="this.onerror=null;this.src='/img/error.png'" alt="Celery"/></a><div class="content"><a class="title" href="/posts/62e0b2c0.html" title="Celery">Celery</a><time datetime="2024-05-07T04:00:00.000Z" title="发表于 2024-05-07 12:00:00">2024-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b543ced0.html" title="RabbitMQ"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_1.png" onerror="this.onerror=null;this.src='/img/error.png'" alt="RabbitMQ"/></a><div class="content"><a class="title" href="/posts/b543ced0.html" title="RabbitMQ">RabbitMQ</a><time datetime="2024-05-07T04:00:00.000Z" title="发表于 2024-05-07 12:00:00">2024-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c24675b4.html" title="MySQL"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_14.png" onerror="this.onerror=null;this.src='/img/error.png'" alt="MySQL"/></a><div class="content"><a class="title" href="/posts/c24675b4.html" title="MySQL">MySQL</a><time datetime="2024-04-22T04:00:00.000Z" title="发表于 2024-04-22 12:00:00">2024-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/65b69107.html" title="Nginx"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_6.png" onerror="this.onerror=null;this.src='/img/error.png'" alt="Nginx"/></a><div class="content"><a class="title" href="/posts/65b69107.html" title="Nginx">Nginx</a><time datetime="2024-03-29T04:00:00.000Z" title="发表于 2024-03-29 12:00:00">2024-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c386cf1b.html" title="Scrapy"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_4.png" onerror="this.onerror=null;this.src='/img/error.png'" alt="Scrapy"/></a><div class="content"><a class="title" href="/posts/c386cf1b.html" title="Scrapy">Scrapy</a><time datetime="2024-03-26T04:00:00.000Z" title="发表于 2024-03-26 12:00:00">2024-03-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/default_cover_3.png')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Maigaleaf</div><div class="footer_custom_text">版本V1.03</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><!-- 按钮阅读进度--><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><!-- 至底--><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script defer src="/js/copy.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="40" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/54924480.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_14.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-21</span><a class="blog-slider__title" href="posts/54924480.html" alt="">Web渗透</a><div class="blog-slider__text">Web渗透概述</div><a class="blog-slider__button" href="posts/54924480.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/3e112b55.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_4.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-11-15</span><a class="blog-slider__title" href="posts/3e112b55.html" alt="">Web语言漏洞</a><div class="blog-slider__text">Web渗透概述</div><a class="blog-slider__button" href="posts/3e112b55.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/4b0178e0.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_11.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-21</span><a class="blog-slider__title" href="posts/4b0178e0.html" alt="">数据结构与算法</a><div class="blog-slider__text">数据结构与算法概述</div><a class="blog-slider__button" href="posts/4b0178e0.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/cc1b9611.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_12.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-21</span><a class="blog-slider__title" href="posts/cc1b9611.html" alt="">JavaScript</a><div class="blog-slider__text">JavaScript概述</div><a class="blog-slider__button" href="posts/cc1b9611.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/b81b1ca5.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_11.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-21</span><a class="blog-slider__title" href="posts/b81b1ca5.html" alt="">masm32汇编</a><div class="blog-slider__text">masm32汇编概述</div><a class="blog-slider__button" href="posts/b81b1ca5.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/c036635b.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_12.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-21</span><a class="blog-slider__title" href="posts/c036635b.html" alt="">PHP</a><div class="blog-slider__text">PHP概述</div><a class="blog-slider__button" href="posts/c036635b.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/a378bd8e.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_2.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-21</span><a class="blog-slider__title" href="posts/a378bd8e.html" alt="">Python</a><div class="blog-slider__text">Python使用概述</div><a class="blog-slider__button" href="posts/a378bd8e.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/cf1dc19e.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default_cover_12.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-21</span><a class="blog-slider__title" href="posts/cf1dc19e.html" alt="">Unity脚本</a><div class="blog-slider__text">Unity脚本程序概述</div><a class="blog-slider__button" href="posts/cf1dc19e.html" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.3.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.8.5" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__fadeIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__fadeInRight');
    arr[i].setAttribute('data-wow-duration', '1.25s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>